; Test program
include "inc/hardware.inc"

section "start", rom0[$0100]
  nop
  jp fn_main

  ; ROM Header
  ROM_HEADER CART_ROM_ONLY, ROM_32K, RAM_NONE

  ; Main program
fn_main:
  nop
  di              ; Disable interrupts
  ld sp, $FFFF    ; Set stack to the end of RAM
  ld a, %11100100 ; Load color palette
                  ; Lighter, 11, 10, 01, 00 Darker
  ld [rBGP], a    ; Load pallete into palette register

  ld a, 0
  ld [rSCX], a    ; Set scroll registers (X/Y) to 0
  ld [rSCY], a

  call fn_switch_screen_off ; Clear LCD before writing to screen

  ; Load tile data to memory
  ld hl, tl_face  ; load tile start address into hl
  ld de, _VRAM    ; load Video RAM address into de
  ld b, tl_bg_length - tl_face ; Number of tiles to load

.loop_copy_tiles:
  ld a, [hl]      ; load tile from tl_face into a
  ld [de], a      ; load a into VRAM
  dec b           ; b = b - 1
  jr z, .loop_copy_tiles_end
  inc hl          ; point to next tile
  inc de          ; point to next address in VRAM
  jr .loop_copy_tiles
.loop_copy_tiles_end:


  ; Not sure what this does anymore
  ld de, $0000
  ld hl, _SCRN0   ; set tile 0 to background tile 0
  ld b, $00
  ld c, $00
.loop_set_tile:
  bit %000, b
  jr nz, .cn_load_mode_2
  bit %000, c
  jr nz, .cn_load_odd_tile
  ld [hl], $00    ; $00 represents the copied tile
  inc hl
  jr .cn_increment_de
.cn_load_odd_tile:
  ld [hl], $01
  inc hl
  jr .cn_increment_de
.cn_load_mode_2:
    bit %000, c
  jr nz, .cn_load_odd_tile_mode_2
  ld [hl], $01    ; $00 represents the copied tile
  inc hl
  jr .cn_increment_de
.cn_load_odd_tile_mode_2:
  ld [hl], $00
  inc hl
.cn_increment_de:
  inc de
  inc c
  ld a, c
  cp $20
  jp z, .cn_skip_tile_flip
  ld a, b
  cp $00
  jp nz, .cn_set_zero
  ld b, $01
  jp .clear_c
.cn_set_zero:
  ld b, $00
.clear_c:
  ld a, $00
  ld c, a
.cn_skip_tile_flip:
  ld a, d
  cp $04
  jr nz, .loop_set_tile
  ld a, e
  cp $00
  jr nz, .loop_set_tile

.loop_set_tiles_end:

  ; Configure and activate display
  ld a, LCDCF_ON | LCDCF_BG8000 | LCDCF_BG9800 | LCDCF_BGON | LCDCF_OBJ8 | LCDCF_OBJOFF
  ld [rLCDC], a

loop_main_loop:
  halt
  nop
  jr loop_main_loop

fn_switch_screen_off:
  ld a, [rLCDC]   ; LCD Control register
  rlca            ; Set highest bit of LCDC into the carry flag
  ret nc          ; Return if display is already off

  ; Wait for VBlank otherwise (to properly switch display off)
.wait_for_vblank
  ld a, [rLY]     ; Line Register (Y)
  cp 145          ; Check if current line is 145
  jr nz, .wait_for_vblank

  ; VBlank confirmed, switch off LCD
  ld a, [rLCDC]   ; load LCD control register content into a
  res 7, a        ; set bit 7 as zero (switch LCD off)
  ld [rLCDC], a
  ret

; Tile bytes
tl_face:
  db $7C, $7C, $82, $FE, $82, $D6, $82, $D6
  db $82, $FE, $82, $BA, $82, $C6, $7C, $7C
tl_face_length:

tl_bg:
  db $AA, $00, $44, $00, $AA, $00, $11, $00
  db $AA, $00, $44, $00, $AA, $00, $11, $00
tl_bg_length: