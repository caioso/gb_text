; Test program
include "inc/hardware.inc"

section "start", rom0[$0100]
  nop
  jp fn_main

  ; ROM Header
  ROM_HEADER CART_ROM_ONLY, ROM_32K, RAM_NONE

  ; Main program
fn_main:
  nop
  di              ; Disable interrupts
  ld sp, $FFFF    ; Set stack to the end of RAM
  ld a, %11100100 ; Load color palette
                  ; Darkest, 11, 10, 01, 00 Lightest
  ld [rBGP], a    ; Load pallete into palette register

  ld a, 0
  ld [rSCX], a    ; Set scroll registers (X/Y) to 0
  ld [rSCY], a

  call fn_switch_screen_off ; Clear LCD before writing to screen

  ; Create lables
;   !alias de, VRAM_pointer
;   !alias hl, tile_pointer
;   !alias b, tile_counter

  ; Load tile data to memory
  ld hl, tl_face  ; load tile start address into hl
  ld de, _VRAM    ; load Video RAM address into de
  ld b, tl_bg_length - tl_white_length ; Number of tiles to load

.loop_copy_tiles:
  ld a, [hl]      ; load tile from tl_face into a
  ld [de], a      ; load a into VRAM
  dec b          ; b = b - 1
  jr z, .loop_copy_tiles_end
  inc hl          ; point to next tile
  inc de          ; point to next address in VRAM
  jr .loop_copy_tiles

  ; Remove labels
;   !unalias VRAM_pointer
;   !unalias tile_pointer
;   !unalias tile_counter

.loop_copy_tiles_end:

;   !alias hl, tile_pointer
;   !alias b, line_counter
;   !alias c, column_counter
  ld hl, _SCRN0   ; set tile 0 to background tile 0
  ; Load alternate tiles to the background
  ; Initialize line counter
  ld b, $00
.loop_b:
  ; Initialize column counter
  ld c, $00
.loop_c:

  ; load tiles
  bit %000, b
  jr z, .loop_load_even_line_tiles
.loop_load_odd_line_tiles
  bit %000, c
  jr z, .loop_load_white_1
.loop_load_black_1
  ld [hl], $02
  jr .loop_write_tile_to_map
.loop_load_white_1
  ld [hl], $03
  jr .loop_write_tile_to_map
.loop_load_even_line_tiles
  bit %000, c
  jr nz, .loop_load_white_2
.loop_load_black_2
  ld [hl], $02
  jr .loop_write_tile_to_map
.loop_load_white_2
  ld [hl], $03
.loop_write_tile_to_map
  inc hl
  ; loop logic
  inc c
  ld a, c
  cp $20
  jr nz, .loop_c

  ; clear column and move to the next line
  inc b
  ld a, b
  cp $20
  jr nz, .loop_b
;   !unalias tile_pointer
;   !unalias column_counter
;   !unalias line_counter

.loop_set_tiles_end:

  ; Configure and activate display
  ld a, LCDCF_ON | LCDCF_BG8000 | LCDCF_BG9800 | LCDCF_BGON | LCDCF_OBJ8 | LCDCF_OBJOFF
  ld [rLCDC], a

;   !alias c, outer_counter
;   !alias d, x_movement
;   !alias e, y_movement

  ld c, $00
loop_main_loop:
.wait_for_vblank:
  ld a, [rLY]     ; Line Register (Y)
  cp 145          ; Check if current line is 145
  jr nz, .wait_for_vblank
  inc c
  ld a, c
  cp $30
  jp nz, loop_main_loop
.cnd_move_bc:
  ld a, $00
  ld c, a
  ld a, d
  inc a
  ld d, a
  ld [rSCX], a    ; Set scroll registers (X/Y) to 0
  ld a, e
  dec a
  ld e, a
  ld [rSCY], a
  jr loop_main_loop

  ; Remove labels
;   !unalias outer_counter
;   !unalias x_movement
;   !unalias y_movement

fn_switch_screen_off:
  ld a, [rLCDC]   ; LCD Control register
  rlca            ; Set highest bit of LCDC into the carry flag
  ret nc          ; Return if display is already off

  ; Wait for VBlank otherwise (to properly switch display off)
.wait_for_vblank
  ld a, [rLY]     ; Line Register (Y)
  cp 145          ; Check if current line is 145
  jr nz, .wait_for_vblank

  ; VBlank confirmed, switch off LCD
  ld a, [rLCDC]   ; load LCD control register content into a
  res 7, a        ; set bit 7 as zero (switch LCD off)
  ld [rLCDC], a
  ret

; Tile bytes
tl_face:
  db $7C, $7C, $82, $FE, $82, $D6, $82, $D6
  db $82, $FE, $82, $BA, $82, $C6, $7C, $7C
tl_face_length:

tl_bg:
  db $AA, $00, $44, $00, $AA, $00, $11, $00
  db $AA, $00, $44, $00, $AA, $00, $11, $00
tl_bg_length:

tl_black:
  db $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
  db $FF, $FF, $FF, $FF, $FF, $FF, $FF, $FF
tl_black_length:

tl_white:
  db $00, $00, $00, $00, $00, $00, $00, $00
  db $00, $00, $00, $00, $00, $00, $00, $00
tl_white_length: